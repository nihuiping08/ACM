/*
　　设a、b是正无理数且 1/a +1/b =1。记P={ [na] | n为任意的正整数}，Q={ [nb] | n 为任意的正整数}，([x]'
  指的是取x的整数部分)则P与Q是Z+的一个划分，即P∩Q为空集且P∪Q为正整数集合Z+。 　　证明：因为a、b为正且
  1/a +1/b=1，则a、b>1，所以对于不同的整数n，[na]各不相同，类似对b有相同的结果。因此任一个整数至多在集
  合P或Q中出现一次。 　　* 现证明P∩Q为空集；(反证法)假设k为P∩Q的一个整数，则存在正整数m、n使得[ma]=[nb]=k。
  即k < ma、nb<k+1，等价地改写不等式为 　　* m/(k+1)< 1/a < m/k及n/(k+1)< 1/b < n/k。相加起来得 
  (m+n)/(k+1) < 1 < (m+n)/k，即 k < m+n < k+1。这与m、n为整数有矛盾，所以P∩Q为空集。 现证明Z+=P∪Q；
  已知P∪Q是Z+的子集，剩下来只要证明Z+是P∪Q的子集。(反证法)假设Z+\(P∪Q)有一个元素k，则存在正整数m、n
  使得[ma]< k <[(m+1)a]、[nb]< k <[(n+1)b]。 由此得ma < k Q[ (m+1)a]-1<(m+1)a -1，类似地有
  nb < k Q[ (n+1)b]-1<(n+1)b -1。等价地改写为 m/k < 1/a < (m+1)/(k+1)及n/k < 1/b < (n+1)/(k+1)。两式加起来，得 
　　(m+n)/k < 1 < (m+n+2)/(k+1)，即m+n < k < k+1 < m+n+2。这与m, n, k皆为正整数矛盾。所以Z+=P∪Q。


例题:

取石子游戏 
Time Limit:1000MS Memory Limit:10000K
Total Submit:3877 Accepted:961

Description
有两堆石子，数量任意，可以不同。游戏开始由两个人轮流取石子。游戏规定，每次有两种不同的取法，一是可以在任
意的一堆中取走任意多的石子；二是可以在两堆中同时取走相同数量的石子。最后把石子全部取完者为胜者。现在给出
初始的两堆石子的数目，如果轮到你先取，假设双方都采取最好的策略，问最后你是胜者还是败者。

Input
输入包含若干行，表示若干种石子的初始情况，其中每一行包含两个非负整数a和b，表示两堆石子的数目，a和b都不
大于1,000,000,000。

Output
输出对应也有若干行，每行包含一个数字1或0，如果最后你是胜者，则为1，反之，则为0。

Sample Input

0
1
0

Sample Output


2 1
8 4
4 7Source
NOI

//下面的内容来自uni

这道题的算法很复杂
首先...存在一个比输序列
如果是比输序列的数对..那么则比输
否则比赢
比输序列的规则是
第N号序列的两数差为N
小的那个数的值是最先的前面数列不出现的整数
1 2 1号
3 5 2号
4 7 3号

所以只要记录N号序列的差和最小数就可以了(序列A)
1 1
2 3
3 4
4 6
5 8

然后计算最小数的逐相差有序列
2 1 2 2 1 2...........

然后可以发现

此序列有递推关系
2 1 2 2 1 2.....
1 0 1 1 0 1 (都减1)
2 1 2 0 2 1 2 1 2 0 2 1 2(中间插入2)
2 1 2 2 1 2 1 2 2 1 2.....(不写0)
变成原来的序列

由此可以推出

序列A的第7号是11的话
那么由于(7+1),(11+2)是费波那切数列
所以(12+1),(19+2)也是费数列
所以第12号是19

又由于

上面的序列变换中
是对称的...

所以可以知道
12+1=11+2=10+3=....
19+1=17+3=16+4=....

所以
如果想知道11 17是不是A序列里的
只要知道 2 3是不是就可以了
(12 19 这个序列可以用菲薄那切法推算出来)

这样...不到23次运算就可以知道100000000000量级的数是不是A序列里的了
当然...也可以由此确定比输序列


//下面的内容来自chengmingvictor

先找规律，算几个很小的必败状态
1，2
3，5
4，7
6，10
8，13
...
发现所有的数恰在序列中出现一次
而且差为1，2，3，4，5，...
所以这两个序列构成正整数集的一个分划，猜想可以由betty定理生成（仅仅是猜想，不需要
太多的理由^_^）
其实，这两个序列恰好对应betty定理中alpha=(1+sqrt(5))/2,beta=(3+sqrt(5))/2的情况，
所以问题解决。

这题不算出公式的话是没法做的，因为规模太大，必败状态太多，没有任何的办法


betty定理是说，如果无理数alpha和beta满足
1.alpha,beta>0
2.1/alpha+1/beta=1
那么，序列{[alpha*n]}和{[beta*n]}构成自然数集的一个分划，其中[]是取整函数

这道题对应的alpha和beta分别是(1+sqrt(5))/2,(3+sqrt(5))/2
所以alpha=1/黄金分割
beta/alpha=黄金分割
可以说跟黄金分割有关，但也只是一种巧合吧，黄金分割还是经常出现的

*/
#include <iostream>
#include <cmath>
using namespace std;
int main()
{
	freopen("sum.in","r",stdin);
	freopen("sum.out","w",stdout);
	double a = (1+sqrt(5.0))/2;
	double b = (3+sqrt(5.0))/2;
	int m,n,x,y,z;
	while(cin>>m>>n)
	{
		if(m==n)
			cout<<1<<endl;
		else
		{
			if(m>n)
				swap(n,m);
			z = (int)ceil(n/b);
			x = (int)(z*a);
			y = (int)(z*b);
			if(x==m&&y==n)
				cout<<0<<endl;
			else
				cout<<1<<endl;
		}
	}
}