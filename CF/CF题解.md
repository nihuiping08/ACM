CF好题：

/**********************************************************/
div 157   
258C - Little Elephant and LCM	:
题目：
    给定一个长度为n的序列{ai}，问有多少个序列{bi}满足，lcm(b1, b2, ... bn) = max(b1, b2, ...bn)，且1<=bi<=ai。
    其中n<=10^5, 1<=ai<=10^5
分析：
    按照ai从小到大排序，方便后续处理。枚举lcm(b1, b2, ... bn) = max(b1, b2, ...bn) = m，我们设m有因子c1, c2 ... ck，
    (c1=1, ck = m)，然后我们按照ci对a分类，设满足大于等于ci, 小于c_(i+1)的共有pi个ai，则对于这部分的ai可以贡献答案 
    i ^ (pi)。如果保证 max(b1, b2, ...bn) = m，假设有pk个ai大于等于m，则通过很容易发现这部分的答案数为
    k^(pk) - k^(pk - 1)，即所有方案减去不存在一个=m的方案，即至少存在一个=m的方案数。因此对与m的答案为
    1^(p1) * 2^(p2) * ... (k-1)^(p_(k-1)) * [ k^(pk) - k^(pk - 1) ]。对于找大于等于ci, 小于c_(i+1)的ai，可以二分查找。
    因此时间复杂度为：O(m*sqrt(m)*logn)。枚举m枚举m的因子，二分查找

/**********************************************************/

div 159		 
257C - View Angle	:极角序

/**********************************************************/

div 161:
263C - Circle of Numbers	:dfs加枚举
263D - Cycle in Graph  
    :长度至少为k+1 个顶点的环，直接爆搜，或者取相邻顶点时间戳最小的点，如果没有时间戳为0的点，说明已存在答案

/**********************************************************/	
div 168:
274B - Zero Tree	:
题目：
    给出棵树，以1为根，每个节点都有初始值，每次选择1的子树，进行+1或者-1操作，问需要多少次，使得树的所有权值均为0。
分析：
    我们发现，从子节点y往上x更新时，向上传add,sub两个参数，表示以y为根的子树需要进行add次add操作，需要进行
    sub次sub操作。所以对于父节点x来说，初始值为val[x]，所以我们首先更新一下val[x]，因为对于子树操作的时候， 
    我们同样需要把x更新，所以val[x] += add-sub。
    如果更新完了之后的val[x]大于0，所以我们需要减掉val[x]，即sub -= val[x]。否则add += val[x]。然后再向x的父节
    点传add,sub两个值。
								 

/**********************************************************/	

8D - Two Friends
题目：
    平面上三个点A,B,C，起初Alice和Bob都在A点，现在Alice需要经过B点然后到达C点，而Bob直接到达C点。现在设计路线
    ，使得两人的最长公共部分最长（一旦分开，以后就算再走到一起也不算）

分析：
    我们设答案为s，所以我们知道Alice和Bob分离点pos在以A为圆心，s为半径的圆上。我们发现pos明显具有单调性。
    我们可以首先二分位置，在BC的线段上的点D，然后再二分出pos在线段AD的具体位置，然后判断该位置是否符合要求就行了。
