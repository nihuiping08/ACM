CF好题：

/**********************************************************/
div 157   
258C - Little Elephant and LCM	:
题目：
　　给定一个长度为n的序列{ai}，问有多少个序列{bi}满足，lcm(b1, b2, ... bn) = max(b1, b2, ...bn)，且1<=bi<=ai。其中n<=10^5, 1<=ai<=10^5
分析：
　　按照ai从小到大排序，方便后续处理。枚举lcm(b1, b2, ... bn) = max(b1, b2, ...bn) = m，我们设m有因子c1, c2 ... ck，(c1=1, ck = m)，然后我们按照ci对a分类，设满足大于等于ci, 小于c_(i+1)的共有pi个ai，则对于这部分的ai可以贡献答案 i ^ (pi)。如果保证 max(b1, b2, ...bn) = m，假设有pk个ai大于等于m，则通过很容易发现这部分的答案数为k^(pk) - k^(pk - 1)，即所有方案减去不存在一个=m的方案，即至少存在一个=m的方案数。因此对与m的答案为
	1^(p1) * 2^(p2) * ... (k-1)^(p_(k-1)) * [ k^(pk) - k^(pk - 1) ]。对于找大于等于ci, 小于c_(i+1)的ai，可以二分查找。
    因此时间复杂度为：O(m*sqrt(m)*logn)。枚举m枚举m的因子，二分查找

/**********************************************************/

div 159		 
257C - View Angle	:极角序

/**********************************************************/

div 161:
263C - Circle of Numbers	:dfs加枚举
263D - Cycle in Graph  
:长度至少为k+1 个顶点的环，直接爆搜，或者取相邻顶点时间戳最小的点，如果没有时间戳为0的点，说明已存在答案

/**********************************************************/	
div 168:
274B - Zero Tree	:
题目：
	给出棵树，以1为根，每个节点都有初始值，每次选择1的子树，进行+1或者-1操作，问需要多少次，使得树的所有权值均为0。
分析：
	我们发现，从子节点y往上x更新时，向上传add,sub两个参数，表示以y为根的子树需要进行add次add操作，需要进行sub次sub操作。所以对于父节点x来说，初始值为val[x]，所以我们首先更新一下val[x]，因为对于子树操作的时候，我们同样需要把x更新，所以val[x] += add-sub。
　　如果更新完了之后的val[x]大于0，所以我们需要减掉val[x]，即sub -= val[x]。否则add += val[x]。然后再向x的父节点传add,sub两个值。
								 
